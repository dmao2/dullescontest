/*
LANG: JAVA
TASK: 
*/

import java.io.*;
import java.util.*;

public class dhsc
{
	public static void main(String[] args) throws IOException
	{
		Scanner c = new Scanner(System.in);
		
		trie t = new trie(); int count=0;
		int e = 0, m = 0, h=0;
		while(true)
		{
			String code = c.next();
			if(code.equals("Done")) 
			{
				t.tab();
				System.out.println(e+" "+m+" "+h);
				break;
			}
			if(code.equals("school"))
			{
				t.add(c.next(), t.root, 0);
			}
			else if(code.equals("kid"))
			{
				count++; String str=""; int g = 0;
				t.add((str=c.next()).toLowerCase(), c.next().toLowerCase(), c.next().toLowerCase(), g=c.nextInt(), c.nextInt());
//				System.out.println(str);
				if(g<6) e++;
				else if(g<9) m++;
				else h++;
			}
			else
			{
				t.update(code.toLowerCase(), c.nextInt(), c.nextInt());
			}
//			t.tab();
//			System.out.println(count);
		}
	}

	public static class trie
	{
		node root = new node('$');
		class node
		{
			char c; 
			private boolean[] is = new boolean[3]; //is[0] = is_school, is[1] = is_fName, is[2] = is_lName
			private int[] score = new int[4];
			private int grade;
			HashMap<Character, node> children = new HashMap<Character, node>();
			public node(char c)
			{
				this.c=c; 
				Arrays.fill(score, -1);
			}
			public int setScore(String name, int sub, int val)
			{
				if(score[sub] == -1) 
				{
					System.out.println(name+" has yet to register for "+toTopic(sub));
					return 1; // not registered
				}
				else if(score[sub] > 0) 
				{
					System.out.println(name+" already has a score of "+score[sub]);
					return 2; // score inputted
				}
				
				System.out.println("Proceed with update of "+val+" in "+toTopic(sub)+" for "+name);
				if(new Scanner(System.in).next().equals("y")) 
				{
					score[sub] = val;
				}
				return 0;
			}
			public boolean isEnd()
			{
				return is[0] || is[1] || is[2];
			}
			public node clone()
			{
				node clone = new node(c);
				clone.is[0] = is[0]; clone.is[1] = is[1]; clone.is[2] = is[2];
				clone.score[0] = score[0]; clone.score[1] = score[1]; clone.score[2] = score[2]; clone.score[3] = score[3];
				clone.children = (HashMap<Character, node>) children.clone();
				return clone;
			}
			public void register(int code)
			{
				for(int i=0; i<4; i++)
				{
					if((code&(1<<i))>0) score[i] = 0;
				}
			}
		}
		
		public int add(String school, String fName, String lName, int grade, int regCode)
		{
			int ret = 0;
			ret += add(school, "", 0); ret += add(fName, school, 1); ret += add(lName, school+fName, 2); 
			if(ret>0) return ret;
			
			setGrade(school+fName+lName, grade);
			register(school+fName+lName, regCode);
			
			return 0;
		}
		
		private int add(String str1, String str2, int type)
		{
			if(!contains(str2, root)) return 1;
			add(str1, strToNode(str2, root), type);
			return 0;
		}
		
		private void register(String str, int regCode)
		{
			strToNode(str, root).register(regCode);
		}
		private void setGrade(String str, int ind)
		{
			strToNode(str, root).grade = ind;
		}
		
		private void add(String str, node rt, int type) // rt adds str, version = is[type].
		{
			node n = rt;
			for(int i=0; i<str.length(); i++)
			{
				if(n.children.containsKey(str.charAt(i)))
					n = n.children.get(str.charAt(i));
				else
				{
					n.children.put(str.charAt(i), new node(str.charAt(i)));
					n = n.children.get(str.charAt(i));
				}
				if(i==str.length()-1) 
				{
					n.is[type] = true;
				}
			}
		}
		public boolean contains(String str, node rt) // check if rt holds prefix str
		{
			node n = rt;
			for(int i=0; i<str.length(); i++)
			{
				if(n.children.containsKey(str.charAt(i)))
					n = n.children.get(str.charAt(i));
				else
					return false;
			}
			return true;
		}
		public boolean containsE(String str, node rt) // check if rt holds word str
		{
			node n = root;
			for(int i=0; i<str.length(); i++)
			{
				if(n.children.containsKey(str.charAt(i)))
					n = n.children.get(str.charAt(i));
				else
					return false;
			}
			return n.isEnd();
		}
		public void remove(String str, node rt) // rt holds str, type = 0:school, 1:f_name, 2:l_name
		{
			if(!containsE(str, rt)) return;
			
			node n = root, lastG = null; int indG = 0;
			for(int i=0; i<str.length(); i++)
			{
				if(n.isEnd() || n.children.size()>1) 
				{
					lastG = n; indG = i;
				}
				n = n.children.get(str.charAt(i));
				if(i==str.length()-1 && n.children.size()>0) 
				{
					n.is[0] = n.is[1] = n.is[2] = false; return;
				}
			}
			lastG.children.remove(str.charAt(indG));
		}
		
		private node strToNode(String str, node rt)
		{
			node n = rt;
			for(int i=0; i<str.length(); i++)
			{
				if(n.children.containsKey(str.charAt(i)))
					n = n.children.get(str.charAt(i));
				else
					return null;
			}
			return n;
		}
			
		public void update(String code, int topic, int score) // given encryption of (school, first, last), tries updating score of topic.
		{
			matches.clear();
			for(int i=0; i<code.length(); i++)
			{
				for(int j=i; j<=code.length(); j++)
				{
					 // 0-->i-1, i-->j, j-->len-1
					find(code.substring(0, i), code.substring(i, j), code.substring(j, code.length()));
				}
			}
			
			if(matches.size()==0) System.out.println("Sorry. No matches.");
			else if(matches.size()>1)
			{
				System.out.println("Multiple matches detected");
				for(String str: matches) System.out.println("-- "+str);
			}
			else 
			{
				for(String str: matches)
				{
					node n = root;
					for(int i=0; i<str.length(); i++)
					{
						if(n.children.containsKey(str.charAt(i)))
							n = n.children.get(str.charAt(i));
					}
					int err = n.setScore(str, topic, score);
				}
			}
		}
		private void find(String school, String name1, String name2) // given that school exists, finds whether student attends school
		{
			node n = root;
			for(int i=0; i<school.length(); i++)
			{
				if(n.children.containsKey(school.charAt(i)))
					n = n.children.get(school.charAt(i));
				else return;
			}
			String[] sendMeOut = {school, name1, name2};
			dfs(n, sendMeOut, 0, (school.length()==0?"":school.substring(0, school.length()-1)));
		}
		
		HashSet<String> matches = new HashSet<String>();
		private void dfs(node n, String[] arr, int type, String ret) // given node n of provided type, adds all students matching data in arr to set 'matches'
		{
			if(n.is[type])
			{
				boolean works = true;
				if(type==2)
				{
					matches.add(ret+n.c); works = false;
				}
				
				node next = n.clone(); 
				for(int i=0; works && i<arr[type+1].length(); i++)
				{
					if(next.children.containsKey(arr[type+1].charAt(i)))
						next = next.children.get(arr[type+1].charAt(i));
					else works = false;
				}
				if(works)
				{
					String str = (arr[type+1].length()==0 ? "":arr[type+1].substring(0, arr[type+1].length()-1));
					dfs(next, arr, type+1, ret+n.c+str);
				}
			}
			for(char ch: n.children.keySet()) dfs(n.children.get(ch), arr, type, ret+n.c);
		}
		
		
		public void tab()
		{
			list.clear();
			String[] base = {"", "", ""};
			getResults(root, base, 0);
			System.out.println(list);
			outputRevenue(root);
			displaySweepstakes();
			displayIndividualResults();
		}
		
		private void displaySweepstakes()
		{
			for(String skool0: skools)
			{
				ArrayList<scoreObject> listo = new ArrayList<scoreObject>();
				listo = getSpecificResults(0, 0, -1, -1, skool0);
				directory.add(new skool(listo, skool0));
			}
			
			for(int i=4; i<=10; i+=3)
			{
				for(int j=0; j<5; j++)
				{
					System.out.println((j==4?"ALL":toTopic(j))+" "+i+" SWEEPSTAKES");
					Collections.sort(directory, toolbox.getComp(j, i));
					for(int k=0; k<4; k++) System.out.println(directory.get(k));
				}
			}
		}
		private class skool
		{
			ArrayList<scoreObject> L0 = new ArrayList<scoreObject>(), L1 = new ArrayList<scoreObject>(), L2 = new ArrayList<scoreObject>(), L3 = new ArrayList<scoreObject>();
			private int s0, s1, s2, s3; String name;
			public skool(ArrayList<scoreObject> L, String name)
			{
				this.name = name;
				for(int i=0; i<L.size(); i++) 
				{
					L0.add(L.get(i)); L1.add(L.get(i)); L2.add(L.get(i)); L3.add(L.get(i));
				}
				
				Collections.sort(L0, new Comparator<scoreObject>()
				{
					public int compare(scoreObject so1, scoreObject so2)
					{
						return so2.score[0] - so1.score[0];
					}
				});
				Collections.sort(L1, new Comparator<scoreObject>()
				{
					public int compare(scoreObject so1, scoreObject so2)
					{
						return so2.score[1] - so1.score[1];
					}
				});
				Collections.sort(L2, new Comparator<scoreObject>()
				{
					public int compare(scoreObject so1, scoreObject so2)
					{
						return so2.score[2] - so1.score[2];
					}
				});
				Collections.sort(L3, new Comparator<scoreObject>()
				{
					public int compare(scoreObject so1, scoreObject so2)
					{
						return so2.score[3] - so1.score[3];
					}
				});
				if(L.size()<4) return;
				s0 = sum0(); s1 = sum1(); s2 = sum2(); s3 = sum3();
			}
			public String toString() {return name;}
			private int sum0() {return L0.get(0).score[0] + L0.get(1).score[0] + L0.get(2).score[0] + L0.get(3).score[0]; }
			private int sum1() {return L0.get(0).score[1] + L0.get(1).score[1] + L0.get(2).score[1] + L0.get(3).score[1]; }
			private int sum2() {return L0.get(0).score[2] + L0.get(1).score[2] + L0.get(2).score[2] + L0.get(3).score[2]; }
			private int sum3() {return L0.get(0).score[3] + L0.get(1).score[3] + L0.get(2).score[3] + L0.get(3).score[3]; }

		}
		ArrayList<skool> directory = new ArrayList<skool>();
		
		private void displayIndividualResults()
		{
			int e = 20, m = 10, h = 1, temp = 0;
			for(int i=4; i<=12; i++)
			{
				if(i==4) temp = e;
				if(i==6) temp = m;
				if(i==9) temp = h;
				ArrayList<scoreObject> listo = new ArrayList<scoreObject>();
				for(int j=0; j<4; j++) 
				{
					listo = getSpecificResults(i, i, j, temp, "");
				
					System.out.println("Grade "+i+" "+toTopic(j)+" INDIVIDUAL");
					for(int k=0; k<listo.size(); k++)
					{
						System.out.println(listo.get(k));
					}
					System.out.println();
				}
			}
		}
		
		private ArrayList<scoreObject> getSpecificResults(int gLo, int gHi, int topic, int places, String school)
		{
			Collections.sort(list, new Comparator<scoreObject>()
			{
				public int compare(scoreObject so1, scoreObject so2)
				{
					if(!matches(gLo, gHi, school, so1.grade, so1.school) && !matches(gLo, gHi, school, so2.grade, so2.school)) return 0;
					if(!matches(gLo, gHi, school, so1.grade, so1.school)) return 1;
					if(!matches(gLo, gHi, school, so2.grade, so2.school)) return -1;
					else if(topic < 0) return 0;
					return so2.score[topic] - so1.score[topic];
				}
			});
			
			ArrayList<scoreObject> ret = new ArrayList<scoreObject>();
			for(int i=0; i<places || (places<0 && matches(gLo, gHi, school, list.get(i).grade, list.get(i).school)); i++)
			{
				ret.add(list.get(i));
			}
			return ret;
		}
		
		private boolean matches(int gLo, int gHi, String school, int t_g, String t_school)
		{
			return (school.equals(t_school) || school.length()==0) && ((gLo*gHi == 0) || ((gLo <= t_g) && (gHi >= t_g)));
		}
		
		ArrayList<scoreObject> list = new ArrayList<scoreObject>();
		HashSet<String> skools = new HashSet<String>();
		private void getResults(node n, String[] arr, int type) // getResults(root...) adds all student's scores into 'list' as scoreObjects
		{
			arr[type] += n.c;
			if(n.is[0]) 
			{
				arr[0]+=arr[1]+arr[2];
				arr[1] = ""; arr[2] = "";
				// ^^ in case of beck / beckendorff cases...
				
				skools.add(arr[0]);
				type=1;
			}
			else if(n.is[1]) type=2;
			else if(n.is[2])
			{
				list.add(new scoreObject(n.score, n.grade, arr[0], arr[1], arr[2])); return;
			}
			for(char c: n.children.keySet())
			{
				getResults(n.children.get(c), arr.clone(), type); 
			}
		}
		
		
		private class scoreObject
		{
			int[] score; int grade; 
			String f_name; String l_name; String school;
			public scoreObject(int[] score, int grade, String school, String f_name, String l_name)
			{
				this.score=score; this.grade=grade; this.f_name=f_name; this.l_name=l_name; this.school=school;
			}
			public String toString()
			{
				return "("+f_name+" "+l_name+" "+grade+" "+school+" "+Arrays.toString(score)+")";
			}
		}
		
		private void outputRevenue(node rt)
		{
			int[] levelMoneys = new int[3];
			dfsMoney(rt, levelMoneys, "");
			System.out.println("money "+Arrays.toString(levelMoneys)+" => total: $"+(levelMoneys[0]+levelMoneys[1]+levelMoneys[2])+".00");
		}
		static int numStudents = 0;
		private int dfsMoney(node rt, int[] levelMoneys, String curPath)
		{
			int count = -1; int ret = 0; curPath += rt.c;
			if(rt.grade!=0)
			{
				if(rt.grade<6) count=0;
				else if(rt.grade<9) count=1;
				else count=2;
			}
			if(count>=0) levelMoneys[count] += (ret = 6*((rt.score[0]>=0?1:0) + (rt.score[1]>=0?1:0) + (rt.score[2]>=0?1:0) + (rt.score[3]>=0?1:0)));

			for(int i: rt.children.keySet())
			{
				ret += dfsMoney(rt.children.get((char) i), levelMoneys, curPath);
			}
			
			if(rt.is[0])
			{
				System.out.println(curPath+": "+ret);
			}
			if(rt.is[2])
			{
				numStudents++;
			}
			return ret;
		}
		
		public static class toolbox
		{
			static Comparator<skool> getComp(int test, int grade)
			{
				return new Comparator<skool>(){ public int compare(skool sk1, skool sk2) { 
					int dif = 0;
					switch(test)
					{
						case 0: dif= sk1.s0-sk2.s0;
						case 1: dif= sk1.s1-sk2.s1;
						case 2: dif= sk1.s2-sk2.s2;
						case 3: dif= sk1.s3-sk2.s3;
						default: dif = sk1.s0+sk1.s1+sk1.s2+sk1.s3 - sk2.s0 - sk2.s1 - sk2.s2 - sk2.s3;
					}
					if(isElem(grade))
					{
						if(!isElem(sk1.L0.get(0).grade)) return 1;
						if(!isElem(sk2.L0.get(0).grade)) return -1;
						return dif;

					}
					else if(isMid(grade))
					{
						if(!isMid(sk1.L0.get(0).grade)) return 1;
						if(!isMid(sk2.L0.get(0).grade)) return -1;
						return dif;
					}
					else
					{
						if(!isMid(sk1.L0.get(0).grade)) return 1;
						if(!isMid(sk2.L0.get(0).grade)) return -1;
						return dif;
					}
				} };
			}
			
			static boolean isElem(int g) { return g<6;}
			static boolean isMid(int g) { return g>5 && g<9; }
			static boolean isHi(int g) {return g>8;}
		}
	}
	
	private static String toTopic(int id)
	{
		switch(id)
		{
			case 0: return "NS";
			case 1: return "CALC";
			case 2: return "MATH";
			default: return "SCI";
		}
	}
}
